utils 
	void	_bzero(void *s, int n)		sからnバイト0で初期化
		例） _bzero(test, sizeof(t_test))   ->   t_test型のtestを0で初期化

	void	_bcopy(void *destvoid     _bcopy(void *dest, void *src, int size)

	void    split_free_all(char **ss)	文字列配列のfree

read_command.c

	char	*read_all(int fd)	fdから読みとってmallocしたやつに格納。失敗したらNULLを返す。要free

	char	**split_command(char *s, char c)	文字列sをcでスプリット（クオーテーション対応）。失敗したらNULLを返す。要free

	void	free_split_command_all(char **s)	split_commandでのmallocをすべてfree

echo.c
	echo -> echoコマンド(with -nオプション)　（コマンドライン引数を　echo　の引数と仮定）

cd.c
	cd -> cdコマンド(相対パスと絶対パス)　（コマンドライン引数を　cd　の引数と仮定）

pwd.c
	pwd -> pwdコマンド　ただpwdするだけ

export.c (未完)
	export->　コマンドライン引数を　export　の引数と仮定して書いていて、コードとして書いたのは引数なしの時だけ（表示内容に自信なし）


argument.c		変数を取り扱うための関数

	#define ARG_TYPE_STR 0
	#define ARG_TYPE_int 0

	typedef struct s_arg
	{
		char *name;
		int type;
		void *data;
	}               t_arg;		変数そのもの

	typedef struct s_arg_list
	{
		t_arg   arg;
		struct s_arg_list  *next;
	}               t_arg_list;		線形リストで管理


	typedef struct s_arg_main
	{
		t_arg_list  head;
		int arg_num;
	}               t_arg_main;		基本これだけ保持しとけばOK

	
	int		arg_main_ini(t_arg_main *arg_main)				プログラムの初めに一度だけ呼ぶ
	int	arg_list_ini(t_arg_main *arg_main)				リストをリセット（$?もリセット）

	int		arg_add(t_arg_main *arg_main, t_arg *arg)		リストへの変数の追加　成功:0　失敗:-1
	void	arg_delete(t_arg *arg, t_arg_list *arg_list)	リストから変数の消去　&  変数のfree 存在しない場合は何もしない
	
	int     arg_get(t_arg_main *arg_main, t_arg *arg, char *name)	nameという名前の変数が存在する場合*argに格納	戻り値　格納:0  存在しない:1　失敗:-1
	char	*arg_to_str(t_arg *arg)							argからname="data"の文字列を作成　戻り値：文字列　失敗またはargがNULLでNULLを返す
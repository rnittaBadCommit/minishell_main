utils 
	void	_bzero(void *s, int n)		sからnバイト0で初期化
		例） _bzero(test, sizeof(t_test))   ->   t_test型のtestを0で初期化

	void	_bcopy(void *destvoid     _bcopy(void *dest, void *src, int size)

	void    split_free_all(char **ss)	文字列配列のfree

read_command.c

	char	*read_all(int fd)	fdから読みとってmallocしたやつに格納。失敗したらNULLを返す。要free

	char	**split_command(char *s, char c)	文字列sをcでスプリット（クオーテーション対応）。失敗したらNULLを返す。要free

	void	free_split_command_all(char **s)	split_commandでのmallocをすべてfree

echo.c
	echo -> echoコマンド(with -nオプション)　（コマンドライン引数を　echo　の引数と仮定）

cd.c
	cd -> cdコマンド(相対パスと絶対パス)　（コマンドライン引数を　cd　の引数と仮定）

pwd.c
	pwd -> pwdコマンド　ただpwdするだけ

export.c (未完)
	export->　コマンドライン引数を　export　の引数と仮定して書いていて、コードとして書いたのは引数なしの時だけ（表示内容に自信なし）


child_process.c
	typedef struct s_cmd
	{
		char *name;
		int (*func)(char **);
	}               t_cmd;		//実際にはこれの配列を使う（最後の要素のnameはNULL）

	int isbuiltin(char *name, t_cmd cmd[], int (**ret)(char **))	nameというビルトイン関数がある場合retに関数ポインタを代入	戻り値：ビルトインのとき1、違ければ0

	int get_path(t_arg *arg_main, char **ret, char *name)		環境変数PATHにnameというファイルがあればretに名前を含むパスを代入	戻り値：存在したら0 しなければ1　失敗で-1


char *separate_redirect(char *command);    | で区切ったレベルのコマンド群（文字列）からレダイレクトの前後をスペースを一つ以上追加してくれる関数

void pipeline(char ***cmd, char ***raw_cmd);
 cmdはstr_Bの文字列配列(整形後)の配列、 raw_cmdはstr_A（つまりはリダイレクトやfilenameを残したままの文字列配列）の配列
　リダイレクトおよびパイプの影響をしっかり受けて実行する関数

//　todo ・パイプで区切られて渡された文字列の文法チェックの関数　・str_Aからstr_Bを作る関数

char **make_strb(char **str_a);
 str_aからstr_bを作ってstr_bを返す関数


argument.c		変数を取り扱うための関数

	#define ARG_TYPE_STR 0
	#define ARG_TYPE_int 0

	typedef struct s_arg
	{
		char *name;
		int type;
		void *data;
	}               t_arg;		変数そのもの

	typedef struct s_arg_list
	{
		t_arg   arg;
		struct s_arg_list  *next;
	}               t_arg_list;		線形リストで管理


	typedef struct s_arg_main
	{
		t_arg_list  head;
		int arg_num;
	}               t_arg_main;		基本これだけ保持しとけばOK

	
	int		arg_main_ini(t_arg_main *arg_main)				プログラムの初めに一度だけ呼ぶ
	int	arg_list_ini(t_arg_main *arg_main)				リストをリセット（$?もリセット）

	int		arg_add(t_arg_main *arg_main, t_arg *arg)		リストへの変数の追加　成功:0　失敗:-1
	void	arg_delete(t_arg *arg, t_arg_list *arg_list)	リストから変数の消去　&  変数のfree 存在しない場合は何もしない
	void    arg_free(t_arg *arg);
	int     arg_get(t_arg_main *arg_main, t_arg *arg, char *name)	nameという名前の変数が存在する場合*argに格納	戻り値　格納:0  存在しない:1　失敗:-1
	char	*arg_to_str(t_arg *arg)							argからname="data"の文字列を作成　戻り値：文字列　失敗またはargがNULLでNULLを返す

